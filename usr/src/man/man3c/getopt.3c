.\"
.\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for
.\" permission to reproduce portions of its copyrighted documentation.
.\" Original documentation from The Open Group can be obtained online at
.\" http://www.opengroup.org/bookstore/.
.\"
.\" The Institute of Electrical and Electronics Engineers and The Open
.\" Group, have given us permission to reprint portions of their
.\" documentation.
.\"
.\" In the following statement, the phrase ``this text'' refers to portions
.\" of the system documentation.
.\"
.\" Portions of this text are reprinted and reproduced in electronic form
.\" in the SunOS Reference Manual, from IEEE Std 1003.1, 2004 Edition,
.\" Standard for Information Technology -- Portable Operating System
.\" Interface (POSIX), The Open Group Base Specifications Issue 6,
.\" Copyright (C) 2001-2004 by the Institute of Electrical and Electronics
.\" Engineers, Inc and The Open Group.  In the event of any discrepancy
.\" between these versions and the original IEEE and The Open Group
.\" Standard, the original IEEE and The Open Group Standard is the referee
.\" document.  The original Standard can be obtained online at
.\" http://www.opengroup.org/unix/online.html.
.\"
.\" This notice shall appear on any product containing this material.
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\"
.\" Copyright 1989 AT&T
.\" Copyright (c) 2001, The IEEE and The Open Group.  All Rights Reserved.
.\" Copyright (c) 2007, Sun Microsystems, Inc.  All Rights Reserved.
.\" Copyright 2018 Jason King
.\"
.Dd Jul 17, 2018
.Dt GETOPT 3C
.Os
.Sh NAME
.Nm getopt
.Nd command option parsing
.Sh SYNOPSIS
.Ss "SVID3, XPG3"
.In stdio.h
.Pp
.Vt extern char *optarg ;
.Vt extern int optind , opterr , optopt ;
.Pp
.Ft int
.Fo getopt
.Fa "int argc" "char * const argv[]" "const char *optstring"
.Fc
.Ss "POSIX.2, XPG4, SUS, SUSv2, SUSv3"
.In unistd.h
.Pp
.Vt extern char *optarg ;
.Vt extern int optind , opterr , optopt ;
.Pp
.Ft int
.Fo getopt
.Fa "int argc" "char * const argv[]" "const char *optstring"
.Fc
.Sh DESCRIPTION
The
.Nm
function is a command line parser that can be used by
applications that follow Basic Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and
10 which parallel those defined by application portability standards (see
.Xr Intro 1 ) .
It can also be used by applications which additionally follow the
Command Line Interface Paradigm (CLIP) syntax extension guidelines 15, 16, and 17.
It partially enforces guideline 18 by requiring that every option has a
short-name, but it allows multiple long-names to be associated with an option.
The remaining guidelines are not addressed by
.Nm
and are the responsibility of the application.
.Pp
The
.Vt argc
and
.Vt argv
arguments are the argument count and argument array as passed to main (see
.Xr exec 2 ) .
The
.Dv optstring
argument specifies the acceptable options.
For utilities wanting to conform to the Basic
Utility Syntax Guidelines,
.Dv optstring
is a string of recognized option characters.
All option characters allowed by Utility Syntax Guideline 3 are
allowed in
.Dv optstring .
If a character is followed by a colon (:), the
option is expected to have an option-argument, which can be separated from it
by white space.
Utilities wanting to conform to the extended CLIP guidelines
can specify long-option equivalents to short options by following the
short-option character (and optional colon) with a sequence of strings, each
enclosed in parentheses, that specify the long-option aliases.
.Pp
The
.Nm
function returns the short-option character in
.Dv optstring
that corresponds to the next option found in
.Dv argv .
.Pp
The
.Nm
function places in
.Dv optind
the
.Dv argv
index of the next argument to be processed.
The
.Dv optind
variable is external and is initialized to 1 before the first call to
.Nm .
The
.Nm
function sets the variable
.Dv optarg
to point to the start of the option-argument as follows:
.Bl -bullet
.It
If the option is a short option and that character is the last character in the
argument, then
.Dv optarg
contains the next element of
.Dv argv ,
and
.Dv optind
is incremented by 2.
.It
If the option is a short option and that character is not the last character in
the argument, then
.Dv optarg
points to the string following the option character in that argument, and
.Dv optind
is incremented by 1.
.It
If the option is a long option and the character equals is not found in the
argument, then
.Dv optarg
contains the next element of
.Dv argv ,
and
.Dv optind
is incremented by 2.
.It
If the option is a long option and the character equals is found in the
argument, then
.Dv optarg
points to the string following the equals character
in that argument and
.Dv optind
is incremented by 1.
.El
.Pp
In all cases, if the resulting value of
.Dv optind
is not less than
.Dv argc ,
this indicates a missing option-argument and
.Nm
returns an error indication.
.Pp
When all options have been processed (that is, up to the first operand),
.Nm
returns \-1.
The special option
.Ql --
(two hyphens) can be used to
delimit the end of the options; when it is encountered, \-1 is returned and
.Ql --
is skipped.
This is useful in delimiting non-option arguments that begin with
.Ql -
(hyphen).
.Pp
If
.Nm
encounters a short-option character or a long-option string
not described in the
.Dv optstring
argument, it returns the question-mark (?) character.
If it detects a missing option-argument, it also returns the
question-mark (?) character, unless the first character of the
.Dv optstring
argument was a colon (:), in which case
.Nm
returns the colon (:) character.
For short options,
.Nm
sets the variable
.Dv optopt
to the option character that caused the error.
For long options,
.Dv optopt
is set to the hyphen (-) character and the failing long option can be identified
through
.Dv argv Ns Bo Dv optind Ns \(mi1 Bc .
If the application has not set the variable
.Dv opterr
to 0 and the first character of
.Dv optstring
is not a colon (:),
.Nm
also prints a diagnostic message to
.Sy stderr .
.Sh RETURN VALUES
The
.Nm
function returns the short-option character associated with the option recognized.
.Pp
A colon (:) is returned if
.Nm
detects a missing argument and the first character of
.Dv optstring
was a colon (:).
.Pp
A question mark (?) is returned if
.Nm
encounters an option not
specified in
.Dv optstring
or detects a missing argument and the first
character of
.Dv optstring
was not a colon (:).
.Pp
Otherwise,
.Nm
returns \-1 when all command line options are parsed.
.Sh ENVIRONMENT
See
.Xr environ 5
for descriptions of the following environment variables
that affect the execution of
.Nm :
.Ev LANG ,
.Ev LC_ALL ,
and
.Ev LC_MESSAGES .
.Bl -tag -width "LC_CTYPE"
.It Ev LC_CTYPE
Determine the locale for the interpretation of sequences of bytes as characters in
.Dv optstring .
.El
.Sh EXAMPLES
\fBExample 1 \fRParsing Command Line Options
.Pp
The following code fragment shows how you might process the arguments for a
utility that can take the mutually-exclusive options
.Fl a
and
.Fl b
and the options
.Fl f
and
.Fl o ,
both of which require arguments:
.Bd -literal -offset 2n
#include <unistd.h>

int
main(int argc, char *argv[ ])
{
    int c;
    int bflg, aflg, errflg;
    char *ifile;
    char *ofile;
    extern char *optarg;
    extern int optind, optopt;
    ...
    while ((c = getopt(argc, argv, ":abf:o:")) != -1) {
        switch(c) {
        case 'a':
            if (bflg)
                errflg++;
            else
                aflg++;
            break;
        case 'b':
            if (aflg)
                errflg++;
            else {
                bflg++;
                bproc();
            }
            break;
        case 'f':
            ifile = optarg;
            break;
        case 'o':
            ofile = optarg;
            break;
        case ':':   /* -f or -o without operand */
            fprintf(stderr,
                   "Option -%c requires an operand\en", optopt);
            errflg++;
            break;
        case '?':
            fprintf(stderr,
                   "Unrecognized option: -%c\en", optopt);
            errflg++;
        }
    }
    if (errflg) {
        fprintf(stderr, "usage: ... ");
        exit(2);
    }
    for ( ; optind < argc; optind++) {
        if (access(argv[optind], R_OK)) {
    ...
}
.Ed
.Pp
This code accepts any of the following as equivalent:
.Bd -literal -offset 2n
cmd -ao arg path path
cmd -a -o arg path path
cmd -o arg -a path path
cmd -a -o arg -- path path
cmd -a -oarg path path
cmd -aoarg path path
.Ed
.Pp
\fBExample 2 \fRCheck Options and Arguments.
.Pp
The following example parses a set of command line options and prints messages
to standard output for each option and argument that it encounters.
.Bd -literal -offset 2n
#include <unistd.h>
#include <stdio.h>
\&...
int c;
char *filename;
extern char *optarg;
extern int optind, optopt, opterr;
\&...
while ((c = getopt(argc, argv, ":abf:")) != -1) {
    switch(c) {
    case 'a':
         printf("a is set\en");
         break;
    case 'b':
         printf("b is set\en");
         break;
    case 'f':
         filename = optarg;
         printf("filename is %s\en", filename);
         break;
    case ':':
         printf("-%c without filename\en", optopt);
         break;
    case '?':
         printf("unknown arg %c\en", optopt);
         break;
    }
}
.Ed
.Pp
This example can be expanded to be CLIP-compliant by substituting the following
string for the
.Dv optstring
argument:
.Bd -literal -offset 2n
:a(ascii)b(binary)f:(in-file)o:(out-file)V(version)?(help)
.Ed
.Pp
and by replacing the '?' case processing with:
.Bd -literal -offset 2n
case 'V':
    fprintf(stdout, "cmd 1.1\en");
    exit(0);
case '?':
    if (optopt == '?') {
        print_help();
        exit(0);
    }
    if (optopt == '-')
        fprintf(stderr,
            "unrecognized option: %s\en", argv[optind-1]);
    else
        fprintf(stderr,
            "unrecognized option: -%c\en", optopt);
    errflg++;
    break;
.Ed
.Pp
and by replacing the ':' case processing with:
.Bd -literal -offset 2n
case ':':   /* -f or -o without operand */
    if (optopt == '-')
        fprintf(stderr,
            "Option %s requires an operand\en", argv[optind-1]);
    else
        fprintf(stderr,
            "Option -%c requires an operand\en", optopt);
    errflg++;
    break;
.Ed
.Pp
While not encouraged by the CLIP specification, multiple long-option aliases
can also be assigned as shown in the following example:
.Bd -literal -offset 2n
:a(ascii)b(binary):(in-file)(input)o:(outfile)(output)V(version)?(help)
.Ed
.Sh ERRORS
No errors are defined.
.Sh USAGE
The
.Nm
function does not fully check for mandatory arguments
because there is no unambiguous algorithm to do so.
Given an option string
\fBa\fR:\fBb\fR and the input
.Fl a
.Fl b ,
.Nm
assumes that
\fB-b\fR is the mandatory argument to the
.Fl a
option and not that
.Fl a
is missing a mandatory argument.
Indeed, the only time a missing
option-argument can be reliably detected is when the option is the final option
on the command line and is not followed by any command arguments.
.Pp
It is a violation of the Basic Utility Command syntax standard (see
.Xr Intro 1 )
for options with arguments to be grouped with other options, as
in
.Ql cmd -abo filename ,
where \fBa\fR and \fBb\fR are options,
\fBo\fR is an option that requires an argument, and
.Ar filename
is the argument to
.Fl o .
Although this syntax is permitted in the current implementation, it should not be used
because it may not be supported in future releases.
The correct syntax to use is:
.Bd -literal -offset 2n
cmd \(miab \(mio filename
.Ed
.Sh INTERFACE STABILITY
Committed
.Sh MT-LEVEL
Unsafe
.Pp
For the Basic Utility Command syntax is Standard, see
.Xr standards 5 .
.Sh SEE ALSO
.Xr getopt 1 ,
.Xr getopts 1 ,
.Xr Intro 1 ,
.Xr getopt_long 3C ,
.Xr getsubopt 3C ,
.Xr gettext 3C ,
.Xr setlocale 3C ,
.Xr attributes 5 ,
.Xr environ 5 ,
.Xr standards 5
